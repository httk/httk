
httk.core package
*****************


Submodules
==========


httk.core.basic module
======================

Basic help functions

httk.core.basic.anonymous_symbol_to_int(symb)

httk.core.basic.breath_first_idxs(dim=1, start=None, end=None, perm=True, negative=False)

httk.core.basic.create_tmpdir()

httk.core.basic.destroy_tmpdir(tmpdir)

httk.core.basic.flatten(l)

httk.core.basic.int_to_anonymous_symbol(i)

httk.core.basic.is_sequence(arg)

httk.core.basic.is_unary(e)

httk.core.basic.main()

httk.core.basic.micro_pyawk(ioa, search, results=None, debug=False, debugfunc=None, postdebugfunc=None)

   Small awk-mimicking search routine.

   'f' is stream object to search through. 'search' is the "search
   program", a list of lists/tuples with 3 elements; i.e.,
   [[regex,test,run],[regex,test,run],...] 'results' is a an object
   that your search program will have access to for storing results.

   Here regex is either as a Regex object, or a string that we compile
   into a Regex. test and run are callable objects.

   This function goes through each line in filename, and if regex
   matches that line *and*  test(results,line)==True (or test == None)
   we execute run(results,match),  where match is the match object
   from running Regex.match.

   The default results is an empty dictionary. Passing a results
   object let you interact  with it in run() and test(). Hence, in
   many occasions it is thus clever to use results=self.

   Returns: results

httk.core.basic.mkdir_p(path)

httk.core.basic.nested_split(s, start, stop)

httk.core.basic.parse_parexpr(string)

   Generate parenthesized contents in string as pairs (level,
   contents).

class class httk.core.basic.rewindable_iterator(iterator)

   Bases: "object"

   next()

   rewind(rewindstr=None)

httk.core.basic.tuple_to_str(t)


httk.core.citation module
=========================

Keep track of citation information for different parts of httk, so
that this info can be printed out on program exit. Turn on either
explicitly by calling httk.config.print_citations_at_exit() from your
program, or implicitly for all software using httk by setting
'auto_print_citations_at_exit=yes' in httk.cfg

Right now this is mostly a proof of concept code, and was added in
response to a concern that co-authors of the software  would not get
credit. We should extend this to add a facility to make it easier to
track and acknowledge citations also of the data being used.

httk.core.citation.add_ext_citation(software, author)

httk.core.citation.add_src_citation(module, author)

httk.core.citation.dont_print_citations_at_exit()

httk.core.citation.print_citations()

httk.core.citation.print_citations_at_exit()


httk.core.code module
=====================

class class httk.core.code.Code(name, version)

   Bases: "httk.core.httkobject.HttkObject"

   Object for keeping track of httk data about a computer software or
   script

   add_ref(ref)

   add_refs(refs)

   add_tag(tag, val)

   add_tags(tags)

   classmethod create(name, version, refs=None, tags=None)

      Create a Computation object.

   get_refs()

   get_tag(tag)

   get_tags()

class class httk.core.code.CodeRef(code, reference)

   Bases: "httk.core.httkobject.HttkObject"

class class httk.core.code.CodeTag(structure, tag, value)

   Bases: "httk.core.httkobject.HttkObject"

httk.core.code.main()


httk.core.computation module
============================

class class httk.core.computation.Computation(computation_date, description, code, manifest_hash, signatures, keys, relpath, project_counter, added_date=None)

   Bases: "httk.core.httkobject.HttkObject"

   Object for keeping track of httk data about a specific computation
   run

   add_project(project)

   add_projects(projects)

   add_ref(ref)

   add_refs(refs)

   add_tag(tag, val)

   add_tags(tags)

   added_date

   classmethod create(computation_date, description, code, manifest_hash, signatures, keys, project_counter, relpath, added_date=None)

      Create a Computation object.

   get_projects()

   get_refs()

   get_tag(tag)

   get_tags()

class class httk.core.computation.ComputationProject(computation, project)

   Bases: "httk.core.httkobject.HttkObject"

   classmethod create(computation, project)

      Create a Computation object.

class class httk.core.computation.ComputationRef(computation, reference)

   Bases: "httk.core.httkobject.HttkObject"

class class httk.core.computation.ComputationRelated(main_computation, other_computation, relation)

   Bases: "httk.core.httkobject.HttkObject"

   Object for keeping track of httk data about a specific computation
   run

   classmethod create(main_computation, other_computation, relation)

      Create a Computation object.

class class httk.core.computation.ComputationTag(computation, tag, value)

   Bases: "httk.core.httkobject.HttkObject"

class class httk.core.computation.Result(computation)

   Bases: "httk.core.httkobject.HttkObject"

   Intended as a base class for results tables for computations

   classmethod create(computation)

      Create a Computation object.

httk.core.computation.main()


httk.core.crypto module
=======================

Provides a few central and very helpful functions for cryptographic
hashes, etc.

httk.core.crypto.generate_keys(public_key_path, secret_key_path)

   Generates a public and a private key pair and stores them in
   respective files

httk.core.crypto.get_crypto_signature(message, secret_key_path)

httk.core.crypto.hexhash_ioa(ioa, prepend=None)

httk.core.crypto.hexhash_str(data, prepend=None)

httk.core.crypto.main()

httk.core.crypto.manifest_dir(basedir, manifestfile, excludespath, keydir, sk, pk, debug=False, force=False)

httk.core.crypto.read_keys(keydir)

httk.core.crypto.sha256file(filename)

httk.core.crypto.tuple_to_hexhash(t)

httk.core.crypto.tuple_to_str(t)

httk.core.crypto.verify_crytpo_signature(signature, message, public_key)

httk.core.crypto.verify_crytpo_signature_old(signature, message, public_key_path)


httk.core.ed25519 module
========================

httk.core.ed25519.H(m)

httk.core.ed25519.Hint(m)

httk.core.ed25519.bit(h, i)

httk.core.ed25519.checkvalid(s, m, pk)

httk.core.ed25519.decodeint(s)

httk.core.ed25519.decodepoint(s)

httk.core.ed25519.edwards(P, Q)

httk.core.ed25519.encodeint(y)

httk.core.ed25519.encodepoint(P)

httk.core.ed25519.expmod(b, e, m)

httk.core.ed25519.inv(x)

httk.core.ed25519.isoncurve(P)

httk.core.ed25519.main()

httk.core.ed25519.publickey(sk)

httk.core.ed25519.scalarmult(P, e)

httk.core.ed25519.signature(m, sk, pk)

httk.core.ed25519.xrecover(y)


httk.core.fracvector module
===========================

class class httk.core.fracvector.FracScalar(nom, denom)

   Bases: "httk.core.fracvector.FracVector"

   Represents the fractional number nom/denom. This is a subclass of
   FracVector with the purpose of making  it clear when a scalar
   fracvector is needed/used.

   classmethod create(nom, denom=None, simplify=True)

      Create a FracScalar.

      FracScalar(something)
         something may be any object that can be used in the
         constructor of the Python Fraction class (also works with
         strings!).

class class httk.core.fracvector.FracVector(noms, denom=1)

   Bases: "object"

   FracVector is a general *immutable* N-dimensional vector (tensor)
   class for performing linear algebra with fractional numbers.

   A FracVector consists of a multidimensional tuple of integer
   nominators, and a single shared integer denominator.

   Since FracVectors are immutable, every operation on a FracVector
   returns a new FracVector with the result of the operation.  A
   created FracVector never changes. Hence, they are safe to use as
   keys in dictionaries, to use in sets, etc.

   Note: most methods returns FracVector results that are not
   simplified (i.e., the FracVector returned does *not* have the
   smallest possible integer denominator). To return a FracVector with
   the smallest possible denominator, just call  FracVector.simplify()
   at the last step.

   T()

      Returns the transpose, A^T.

   argmax()

      Return the index of the maximum element across all dimensions in
      the FracVector.

   argmin()

      Return the index of the minimum element across all dimensions in
      the FracVector.

   ceil()

      Returns the integer that is equal to or just below the value
      stored in a scalar FracVector.

   classmethod chain_vecs(vecs)

      Optimized chaining of FracVectors.

      vecs: a list (or tuple) of fracvectors.

      Returns the same thing as
         FracVector.create(vecs,chain=True)

      i.e., removes outermost dimension and chain the sub-sequences.
      If input=[[1 2 3],[4,5,6]], then
         FracVector.chain(input) -> [1,2,3,4,5,6]

      but this method assumes all vectors share the same denominator
      (it raises an exception if this is not true)

   classmethod create(noms, denom=None, simplify=True, chain=False)

      Create a FracVector from various types of sequences.

      Simplest use:

         FracVector.create(some_kind_of_sequence)

      where 'some_kind_of_sequence' can be any nested list or tuple of
      objects that can be used in the constructor  of the Python
      Fraction class (also works with strings!). If any object found
      while traveling the items has a  .to_fractions() method, it will
      be called and is expected to return a fraction or list or tuple
      of fractions.

      Optional parameters:

      * Invocation with denominator:
        FracVector.create(nominators,denominator)   nominators is any
        sequence, and denominator a common denominator to divide all
        nominators with

      * simplify: boolean, return a FracVector with the smallest
        possible denominator.

      * chain: boolean, remove outermost dimension and chain the
        sub- sequences. I.e., if input=[[1 2 3],[4,5,6]], then
        FracVector.create(input) -> [1,2,3,4,5,6]

      Relevant: FracVector itself implements .to_fractions(), and
      hence, the same constructor allows stacking several FracVector
      objects like this:

         vertical_fracvector = FracVector([[fracvector1],[fracvector2]])
         horizontal_fracvector = FracVector([fracvector1,fracvector2],chain=True)

   cross(other)

      Returns the vector cross product of the 3-element 1D vector with
      the 3-element 1D vector 'other', i.e., A x B.

   det()

      Returns the determinant of the FracVector as a scalar
      FracVector.

   dim

      This property returns a tuple with the dimensionality of each
      dimension of the FracVector  (the noms are assumed to be a
      nested list of rectangular shape).

   dot(other)

      Returns the vector dot product of the 1D vector with the 1D
      vector 'other', i.e., A . B or A cdot B. The same as A * B.T().

   classmethod eye(dims)

      Create a diagonal one-matrix with the given dimensions

   flatten()

      Returns a FracVector that has been flattened out to a single
      rowvector

   floor()

      Returns the integer that is equal to or just below the value
      stored in a scalar FracVector.

   classmethod from_floats(l, resolution=4294967296)

      Create a FracVector from a (nested) list or tuple of floats. You
      can convert a numpy array with this method if you use A.tolist()

      resolution: the resolution used for interpreting the given
      floating point numbers. Default is 2^32.

   classmethod from_tuple(t)

      Return a FracVector created from the tuple representation:
      (denom, ...noms...), returned by the to_tuple() method.

   ged_prestacked(other)

   ged_stackedinsert(pos, other)

   get_append(other)

   get_extend(other)

   get_insert(pos, other)

   get_prepend(other)

   get_prextend(other)

   get_stacked(other)

   inv()

      Returns the matrix inverse, A^-1

   lengthsqr()

      Returns the square of the length of the vector. The same as A *
      A.T()

   limit_denominator(max_denom=1000000000)

      Returns a FracVector of reduced resolution.

      resolution: each element in the returned FracVector is the
      closest numerical approximation that can is allowed by  a
      fraction with maximally this denominator. Note: since all
      elements must be put on a common denominator, the result may
      have a larger denominator than max_denom

   max()

      Return the maximum element across all dimensions in the
      FracVector. max(fracvector) works for a 1D vector.

   metric_product(vecA, vecB)

      Returns the result of the metric product using the present
      square FracVector as the metric matrix. The same as
         vecA*self*vecB.T().

   min()

      Return the minimum element across all dimensions in the
      FracVector. max(fracvector) works for a 1D vector.

   mul(other)

      Returns the result of multiplying the vector with 'other' using
      matrix multiplication.

      Note that for two 1D FracVectors, A.dot(B) is *not* the same as
      A.mul(B), but rather: A.mul(B.T()).

   nargmax()

      Return a list of indices of all maximum elements across all
      dimensions in the FracVector.

   nargmin()

      Return a list of indices for all minimum elements across all
      dimensions in the FracVector.

   static nested_map(op, *ls)

      Map an operator over a nested tuple. (i.e., the same as the
      built-in map(), but works recursively on a nested tuple)

   static nested_map_fractions(op, *ls)

      Map an operator over a nested tuple, but checks every element
      for a method to_fractions()  and uses this to further convert
      objects into tuples of Fraction.

   nom

      Returns the integer nominator of a scalar FracVector.

   normalize()

      Add/remove an integer +/-N to each element to place it in the
      range [0,1)

   normalize_half()

      Add/remove an integer +/-N to each element to place it in the
      range [-1/2,1/2)

      This is useful to find the shortest vector C between two points
      A, B in a space with periodic boundary conditions [0,1):
         C = (A-B).normalize_half()

   classmethod random(dims, minnom=-100, maxnom=100, denom=100)

      Create a zero matrix with the given dimensions

   reciprocal()

   classmethod set_common_denom(A, B)

      Used internally to combine two different FracVectors.

      Returns a tuple (A2,B2,denom) where A2 is numerically equal to
      A, and B2 is numerically equal to B, but A2 and B2 are both  set
      on the same shared denominator 'denom' which is the *product* of
      the denominator of A and B.

   set_denominator(set_denom=1000000000)

      Returns a FracVector of reduced resolution where every element
      is the closest numerical approximation using this denominator.

   sign()

      Returns the sign of the scalar FracVector: -1, 0 or 1.

   simplify()

      Returns a reduced FracVector. I.e., each element has the same
      numerical value  but the new FracVector represents them using
      the smallest possible shared denominator.

   classmethod stack_vecs(vecs)

      Optimized stacking of FracVectors.

      vecs = a list (or tuple) of fracvectors.

      Returns the same thing as:

         FracVector.create(vecs)

      but only works if all vectors share the same denominator (raises
      an exception if this is not true)

   to_float()

      Converts a scalar ExactVector to a single float.

   to_floats()

      Converts the ExactVector to a list of floats.

   to_fraction()

      Converts scalar FracVector to a fraction.

   to_fractions()

      Converts the FracVector to a list of fractions.

   to_int()

      Converts scalar FracVector to an integer (truncating as
      necessary).

   to_ints()

      Converts the FracVector to a list of integers, rounded off as
      best possible.

   to_tuple()

      Return a FracVector on tuple representation: (denom,
      ...noms...).

   classmethod use(old)

      Make sure variable is a FracVector, and if not, convert it.

   validate()

   classmethod zeros(dims)

      Create a zero matrix with the given dimensions

httk.core.fracvector.main()

httk.core.fracvector.nested_map_fractions_list(op, *ls)

   Map an operator over a nested list, but checks every element for a
   method to_fractions()  and uses this to further convert objects
   into lists of Fraction.

httk.core.fracvector.nested_map_fractions_tuple(op, *ls)

   Map an operator over a nested tuple, but checks every element for a
   method to_fractions()  and uses this to further convert objects
   into tuples of Fraction.

httk.core.fracvector.nested_map_list(op, *ls)

   Map an operator over a nested list. (i.e., the same as the built-in
   map(), but works recursively on a nested list)

httk.core.fracvector.nested_map_tuple(op, *ls)

   Map an operator over a nested tuple. (i.e., the same as the built-
   in map(), but works recursively on a nested tuple)

httk.core.fracvector.nested_reduce(op, l, initializer=None)

   Same as built-in reduce, but operates on a nested
   tuple/list/sequence.

httk.core.fracvector.nested_reduce_fractions(op, l, initializer=None)

   Same as built-in reduce, but operates on a nested
   tuple/list/sequence. Also checks every element for a method
   to_fractions() and uses this to further convert such elements to
   lists of fractions.

httk.core.fracvector.nested_reduce_levels(op, l, level=1, initializer=None)

   Same as built-in reduce, but operates on a nested
   tuple/list/sequence.

httk.core.fracvector.tuple_eye(dims, onepos=0)

   Create a matrix with the given dimensions and 1 on the diagonal

httk.core.fracvector.tuple_index(dims, uppidx=())

   Create a nested tuple where every element is a tuple indicating the
   position of that tuple

httk.core.fracvector.tuple_random(dims, minval, maxval)

   Create a nested tuple with the given dimensions filled with random
   numbers between minval and maxval

httk.core.fracvector.tuple_slice(l, key)

   Given a python slice (i.e., what you get to __getitem__ when you
   write A[3:2]), cut out the relevant nested tuple.

httk.core.fracvector.tuple_zeros(dims)

   Create a netsted tuple with the given dimensions filled with zeroes


httk.core.geometry module
=========================

Basic geometry helper functions

httk.core.geometry.hull_z(points, zs)

   points: a list of points=(x,y,..) with zs= a list of z values; a
   convex half-hull is constructed over negative z-values

   returns data on the following format.:

      {
        'hull_points': indices in points list for points that make up the convex hull, 
         'interior_points':indices for points in the interior, 
         'interior_zs':interior_zs
         'zs_on_hull': hull z values for each point (for points on the hull, the value of the hull if this point is excluded)
         'closest_points': list of best linear combination of other points for each point 
         'closest_weights': weights of best linear combination of other points for each point 
      }

   where hull_points and interior_points are lists of the points on
   the hull and inside the hull. and

      hull_zs is a list of z-values that the hull *would have* at that
      point, had this point not been included. interior_zs is a list
      of z-values that the hull has at the interior points.

httk.core.geometry.is_any_part_of_cube_inside_cell(cell, midpoint, side)

   Checks if any part of a cube is inside the cell spanned by the
   vectors in cell

httk.core.geometry.is_point_inside_cell(cell, point)

   Checks if a given triple-vector is inside the cell given by the
   basis matrix in cell

httk.core.geometry.is_point_inside_tetra(tetra, point)

   Checks if a point is inside the tretrahedra spanned by the
   coordinates in tetra

httk.core.geometry.numpy_quickhull_2d(sample)

httk.core.geometry.simplex_le_solver(a, b, c)

   Minimizie func = a[0]*x + a[1]*y + a[2]*z + ... With constraints:

      b[0,0]x + b[0,1]y + b[0,2]z + ... <= c[0]
      b[1,0]x + b[1,1]y + b[1,2]z + ... <= c[1]
      ...
      x,y,z, ... >= 0

   Algorithm adapted from 'taw9', http://taw9.hubpages.com/hub
   /Simplex-Algorithm-in-Python


httk.core.httkobject module
===========================

class class httk.core.httkobject.HttkObject

   Bases: "object"

   get_codependent_data()

   hexhash

   classmethod new_from(other)

   to(newtype)

   to_tuple(use_hexhash=False)

   classmethod types()

   classmethod use(old)

class class httk.core.httkobject.HttkPlugin

   Bases: "object"

class class httk.core.httkobject.HttkPluginPlaceholder(plugininfo=None)

   Bases: "object"

class class httk.core.httkobject.HttkPluginWrapper(plugin=None)

   Bases: "object"

class class httk.core.httkobject.HttkTypedProperty(property_type, fget=None, fset=None, fdel=None, doc=None)

   Bases: "property"

httk.core.httkobject.httk_typed_init(t, **kargs)

httk.core.httkobject.httk_typed_init_delayed(t, **kargs)

httk.core.httkobject.httk_typed_property(t)

httk.core.httkobject.httk_typed_property_delayed(t)

httk.core.httkobject.httk_typed_property_resolve(cls, propname)


httk.core.ioadapters module
===========================

class class httk.core.ioadapters.IoAdapterFileAppender(f, name=None)

   Bases: "object"

   Io adapter for access to data as a python file object

   close()

   classmethod use(other)

class class httk.core.ioadapters.IoAdapterFileReader(f, name=None, deletefilename=None, close=False)

   Bases: "object"

   Io adapter for easy handling of io.

   close()

   classmethod use(other)

class class httk.core.ioadapters.IoAdapterFileWriter(f, name=None, close=False)

   Bases: "object"

   Io adapter for access to data as a python file object

   close()

   classmethod use(other)

class class httk.core.ioadapters.IoAdapterFilename(filename, name=None, deletefilename=None)

   Bases: "object"

   Universal io adapter, helps handling the passing of filenames,
   files, and strings to functions that deal with io

   close()

   classmethod use(other)

class class httk.core.ioadapters.IoAdapterString(string=None, name=None)

   Bases: "object"

   Universal io adapter, helps handling the passing of filenames,
   files, and strings to functions that deal with io

   close()

   string

   classmethod use(other)

class class httk.core.ioadapters.IoAdapterStringList(stringlist, name=None)

   Bases: "object"

   Universal io adapter, helps handling the passing of filenames,
   files, and strings to functions that deal with io

   classmethod use(other)

httk.core.ioadapters.cleveropen(filename, mode, *args)

httk.core.ioadapters.universal_opener(other)

httk.core.ioadapters.zdecompressor(f, mode, *args)

   Read a classic unix compress .Z type file.


httk.core.mutablefracvector module
==================================

class class httk.core.mutablefracvector.MutableFracVector(noms, denom)

   Bases: "httk.core.fracvector.FracVector"

   Same as FracVector, only, this version allow assignment of
   elements, e.g.,

      mfracvec[2,7] = 5

   and, e.g.,

      mfracvec[:,7] = [1,2,3,4] 

   Other than this, the FracVector methods exist and do the same,
   i.e., they return *copies* of the fracvector, rather  than
   modifying it.

   However, methods have also been added named with set_* prefixes
   which performs mutating operations, e.g.,

      A.set_T()

   replaces A with its own transpose, whereas

      A.T()

   just returns a new MutableFracVector that is the transpose of A,
   leaving A unmodified.

   classmethod from_FracVector(other)

      Create a MutableFracVector from a FracVector.

   invalidate()

      Internal method to call when MutableFracVector is changed in
      such a way that cached properties are invalidated (e.g., _dim)

   static nested_inmap(op, *ls)

      Like inmap, but work for nested lists

   static nested_map(op, *ls)

      Map an operator over a nested list. (i.e., the same as the
      built-in map(), but works recursively on a nested list)

   static nested_map_fractions(op, *ls)

      Map an operator over a nested list, but checks every element for
      a method to_fractions()  and uses this to further convert
      objects into lists of Fraction.

   set_T()

      Changes MutableFracVector inline into own transpose: self ->
      self.T

   set_inv()

      Changes MutableFracVector inline into own inverse: self ->
      self^-1

   set_negative()

      Changes MutableFracVector inline into own negative: self ->
      -self

   set_normalize()

      Add/remove an integer +/-N to each element to place it in the
      range [0,1)

   set_normalize_half()

      Add/remove an integer +/-N to each element to place it in the
      range [-1/2,1/2)

      This is useful to find the shortest vector C between two points
      A, B in a space with periodic boundary conditions [0,1):
         C = (A-B).normalize_half()

   set_set_denominator(resolution=1000000000)

      Changes MutableFracVector; reduces resolution.

         resolution is the new denominator, each element becomes the
         closest numerical approximation using this denominator.

   set_simplify()

      Changes MutableFracVector; reduces any common factor between
      denominator and all nominators

   to_FracVector()

      Return a FracVector with the values of this MutableFracVector.

   classmethod use(old)

      Make sure variable is a MutableFracVector, and if not, convert
      it.

   validate()

httk.core.mutablefracvector.inmap(f, x)

   Like built-in map, but work on a list and *replace* the elements in
   the list with the result of the mapping.

httk.core.mutablefracvector.list_set_slice(l, key, values)

   Given:
      l = list,  key = python slice (i.e., what you get to __setitem__
      when you write A[3:2]=[2,5]) values = a list of values,

   change the elements specified by the slice in key to those given by
   values.

httk.core.mutablefracvector.list_slice(l, key)

   Given a python slice (i.e., what you get to __getitem__ when you
   write A[3:2]), cut out the relevant nested list.

httk.core.mutablefracvector.main()

httk.core.mutablefracvector.nested_inmap_list(op, *ls)

   Like inmap, but work for nested lists


httk.core.project module
========================

class class httk.core.project.Project(name, description, project_key, keys)

   Bases: "httk.core.httkobject.HttkObject"

   add_ref(ref)

   add_refs(refs)

   add_tag(tag, val)

   add_tags(tags)

   classmethod create(name, description, project_key, keys)

      Create a Project object.

   get_refs()

   get_tag(tag)

   get_tags()

class class httk.core.project.ProjectOwner(project, owner_key)

   Bases: "httk.core.httkobject.HttkObject"

   classmethod create(project, owner)

      Create a Project object.

class class httk.core.project.ProjectRef(project, reference)

   Bases: "httk.core.httkobject.HttkObject"

class class httk.core.project.ProjectTag(project, tag, value)

   Bases: "httk.core.httkobject.HttkObject"

httk.core.project.main()


httk.core.reference module
==========================

class class httk.core.reference.Author(last_name, given_names)

   Bases: "httk.core.httkobject.HttkObject"

   Object for keeping track of tags for other objects

   classmethod create(last_name, given_names)

      Create a Author object.

class class httk.core.reference.Reference(ref, authors=None, editors=None, journal=None, journal_issue=None, journal_volume=None, page_first=None, page_last=None, title=None, year=None, book_publisher=None, book_publisher_city=None, book_title=None)

   Bases: "httk.core.httkobject.HttkObject"

   A reference citation

   classmethod create(ref=None, authors=None, editors=None, journal=None, journal_issue=None, journal_volume=None, page_first=None, page_last=None, title=None, year=None, book_publisher=None, book_publisher_city=None, book_title=None)

      Create a Reference object.

httk.core.reference.main()


httk.core.signature module
==========================

class class httk.core.signature.Signature(signature_data, key)

   Bases: "httk.core.httkobject.HttkObject"

   classmethod create(signature_data, key)

      Create a Computation object.

class class httk.core.signature.SignatureKey(keydata, description)

   Bases: "httk.core.httkobject.HttkObject"

   classmethod create(keydata, description)

      Create a Computation object.

httk.core.signature.main()


httk.core.template module
=========================

httk.core.template.apply_template(template, output, envglobals=None, envlocals=None)

   Simple Python template engine.

   The file 'template' is turned into a new file 'output' replacing
   the following: $name -> the value of the variable 'name' in the
   scope provided by locals and globals.  $(python statement) ->
   result of evaluating the python statment. ${some python code} ->
   text on stdout from running that python code.

   Note: it is safe for the code inside the template  to load the file
   it eventually will replace.

httk.core.template.apply_templates(inputpath, outpath, template_suffixes='template', envglobals=None, envlocals=None, mkdir=True)

   Apply one or a series of templates throughout directory tree.

   template_suffixes: string or list of strings that are the suffixes
   of templates that are to be applied. name: subdirectory in which to
   apply the template, defaults to last subrun created, or '.' if no
   subrun have been created.


Module contents
===============

httk core module

Basic utilities and data definitions that are used throughout the httk
code.

A few of the most important components:
   fracvector: our general matrix object used to allow exact
   representation of arrays to allow, e.g., exact matching
      of coordinates to existing structures in the database.

   ioadapters: our classes for generic handling of IO to files,
   streams, etc.

   structure: our basic definition of a "structure of atoms"
