
httk.db package
***************


Subpackages
===========

* httk.db.backend package

  * Submodules

  * httk.db.backend.sqlite module

  * Module contents

* httk.db.store package

  * Submodules

  * httk.db.store.dictstore module

  * httk.db.store.sqlstore module

  * httk.db.store.trivialstore module

  * Module contents


Submodules
==========


httk.db.filteredcollection module
=================================

class class httk.db.filteredcollection.BinaryBooleanOp(context, operator, left, right)

   Bases: "httk.db.filteredcollection.Expression"

class class httk.db.filteredcollection.BinaryComparison(context, operator, left, right)

   Bases: "httk.db.filteredcollection.Expression"

class class httk.db.filteredcollection.BinaryOp(context, operator, left, right)

   Bases: "httk.db.filteredcollection.Expression"

class class httk.db.filteredcollection.DeclaredFunction(context, name, srctable=None)

   Bases: "object"

class class httk.db.filteredcollection.Expression(context, exprtype, *args)

   Bases: "object"

   get_srctable_context()

   is_in(*args)

class class httk.db.filteredcollection.FCDict(data=None)

   Bases: "httk.db.filteredcollection.FilteredCollection"

   This implements a filtered collection purely backed by a dictionary
   and python evaluation.

   Note: FCSqliteMemory will usually be faster. (However, you need
   this class if you need to express filters and expressions using
   python functions rather than Sqlite functions.)

   copy()

   data(outid=None)

      Return an object where the attributes are accessible as
      properties. I.e.
         data = myFCDict.data myFCDict.set_filter(data.example ==
         data.otherexample*2)

   function(name)

      Define a python function object for use when expressing filter
      queries and column expressions. (You cannot define a filter with
      a "bare function", since it would be called directly at the
      point of defining the filter.) Validy/existence of this function
      is not checked until the collection is iterated over.

class class httk.db.filteredcollection.FCMultiDict(data=None)

   Bases: "httk.db.filteredcollection.FilteredCollection"

   This class allows you to combine a number of filtered collections
   and put filters on any combination of them together. Just create a
   separate FilteredCollection from each data source, and pass them in
   a list to the constructor of this class.

   Filters that only apply to one of the FilteredCollections can be
   put on those collections instead, while a filter that applies to
   more than one must be set on this class.

   add(filterexpr)

      Append a filter to the filters currently filtering the
      FilteredCollection. When iterating over the  FilteredCollection,
      a result is only included if it matches all the filters.

   copy()

   data(name, outid=None)

      Return an object where the attributes of respective filtered
      collection is accessible as attributes. An example:

         languagereview = FCMultiDict('programming':programming_fc,
         'review':review_fc) language =
         languagereview.data('programming').language review =
         languagereview.data('review')
         myFCMultiDict.set_filter(language.name == "python" &
         review.goodness > 9)

   subdata(name, table, outid=None, key='rowid', subkey=None)

      Return an object where the attributes of respective filtered
      collection is accessible as attributes. An example:

         languagereview = FCMultiDict('programming':programming_fc,
         'review':review_fc) language =
         languagereview.data('programming').language review =
         languagereview.data('review')
         myFCMultiDict.set_filter(language.name == "python" &
         review.goodness > 9)

class class httk.db.filteredcollection.FCMultiSqlite(dicts=None)

   Bases: "httk.db.filteredcollection.FilteredCollection"

   This class allows you to combine a number of filtered collections
   and put filters on any combination of them together. Just create a
   separate FilteredCollection from each data source, and pass them in
   a list to the constructor of this class.

   Filters that only apply to one of the FilteredCollections should
   preferably be put on those collections, while a filter that applies
   to more than one must be set on this class, *using field
   definitions made with this class*.

class class httk.db.filteredcollection.FCSqlite(sqlstore)

   Bases: "httk.db.filteredcollection.FilteredCollection"

   function(name)

      Define a function object for expressing functions in filter
      queries. Validity/existence of this function may not be tested
      until an iteration over matching entries is performed.

   sql()

   store_table(name)

   subtable(name, table, outid=None, key='rowid', subkey=None)

      Defines a table object to use in filters (for add) and
      expressions (in set_columns).

   table(name, outid=None)

      Defines a table object to use in filters (for add) and
      expressions (in set_columns).

class class httk.db.filteredcollection.FilteredCollection

   Bases: "object"

   Main interface for filtered collections.

   Apart from what is declared here, each subclass should define e.g.
   'table', 'column', 'function' methods for defining fields for use
   for filters (in, e.g., set_filter) and expressions (in, e.g.,
   set_columns).

   add(filterexpr)

      Append a filter to the filters currently filtering the
      FilteredCollection. When iterating over the  FilteredCollection,
      a result is only included if it matches all the filters.

   add_all(filterexpr)

      Append a filter to the filters currently filtering the
      FilteredCollection. When iterating over the  FilteredCollection,
      a result is only included if it matches all the filters.

   add_sort(expression, direction='ASC')

      Define which columns should be included in the results when
      iterating over a FilteredCollection.  attributes is a list of
      tuples consisting of (name,definition) where definition can be
      any expression in columns.

      Default is to show all columns of all tables defined. (See
      FilteredColleciton.table)

   duplicate(other)

   output(expression, name=None)

      Define which columns should be included in the results when
      iterating over a FilteredCollection.  attributes is a list of
      tuples consisting of (name,definition) where definition can be
      any expression in columns.

      Default is to show all columns of all tables defined. (See
      FilteredColleciton.table)

   reset()

      Clear any filtering done on the data source.

   store_table(name)

      Store the result of the filtered collection in a new table named
      'name'.

   variable(obj, outid=None, parent=None, parentkey=None, subkey=None)

class class httk.db.filteredcollection.Function(context, name, srctable, *args)

   Bases: "httk.db.filteredcollection.Expression"

class class httk.db.filteredcollection.TableOrColumn(context, name, parent=None, outid=None, key=None, subkey=None, srctable=None, indirection=1, classref=None)

   Bases: "httk.db.filteredcollection.Expression"

class class httk.db.filteredcollection.UnaryBooleanOp(context, operator, right)

   Bases: "httk.db.filteredcollection.Expression"

httk.db.filteredcollection.fc_checkcontext(context, *exprs)

httk.db.filteredcollection.fc_eval(expr, data)

httk.db.filteredcollection.fc_get_srctable_context(*args)

httk.db.filteredcollection.fc_sql(expr)

httk.db.filteredcollection.instantiate_from_store(classobj, store, id)


httk.db.httkobjdbplugin module
==============================

class class httk.db.httkobjdbplugin.HttkObjDbPlugin

   Bases: "httk.core.httkobject.HttkPlugin"

   fetch_codependent_data(store)

   plugin_init(obj)

   store(store, avoid_duplicate=True)

   store_codependent_data(store)


httk.db.storable module
=======================

class class httk.db.storable.Storable(types=None, index=None)

   Bases: "object"

   Superclass for handling various forms of data storage, retreival,
   etc. Class object representing data should inherit from Storable.

   All public variables must be initalized in a call to
   storable_init() inside __init__(). Other member variables are OK,
   but must begin with '_', and all methods must handle these
   variables not being initialized. For private variables that needs
   to be preserved: let them start with '_' AND declare them in
   storable_init().

   classmethod find_all(obj, store, member, value, types)

      Convinience method to do a very simple search of type: find all
      entries where member = value.

   classmethod find_one(obj, store, member, value, types)

      Convinience^2 method to do a very simple search of type: find
      one entry where member = value.

   storable_init(store, updatesid=None, **keyvals)

      All Storable objects need to call this method in __init__().
      Name should be a 'somewhat qualified' class name.

   trivialstore = <httk.db.storable.TrivialStore object at 0x2ab184e72350>

   classmethod variable(searcher, name, types, outid=None, parent=None)

class class httk.db.storable.TrivialStore

   Bases: "object"

   Very simple storage class that just stores everything into an
   individual dictionary, just like regular python objects work

   new(table, types, keyvals)

   retrieve(table, types, sid)

httk.db.storable.storable_props(*props)

httk.db.storable.storable_types(name, *keyvals, **flags)


Module contents
===============
